### fpga_rocket_launcher

# Digital Model Rocket Launch Controller

A FPGA based model rocket digital launch controller.

A low tech approach using digital gates only, no CPUs.

![git commit hash overlay](commit_overlay.jpeg "Estes Igniter test")

Showing using an Estes igniter. Observed low resistance (~ 1ohm) and takes 4 Joules at 4 amps for about 300msec.

![Assembled and testing](pcb_v0_8_assy.jpg "Digital Launch Controller Prototype")

[Schematic](fpga_blaster_schem_v0_8.pdf)

### Digital constant current capacitive discharge launch controller.

## Core function

Powered by 4xAA Lithium batteries capable 1A of current. 
When armed, the controller charges a 200uF capactor bank to 320V with a flyback converter giving 10 Joules of stored energy. 
Upon launch, the capacitor is discharged through a 390uH inductor into the igniter.
The discharge is modulated by a FET with a PWM gate drive.
Discharge is digitally current controlled as a buck converter with a current setpoint in the range of 2.0 to 6.0 amps.
The setup current is maintained over the full capacitor discharge, or until the ignitor burns through and the circuit opens.

The digital control system uses a differential analog front end is used to isolate and instrument capacitor and output IVs.
12-bit ADC samples The four signals (cap/out,I/V) are simultaneously sampled and digitized 3 Mhz and fed into the digital system.

The PWM signal is generated by a control loop running at 48 Mhz (16x sample rate). 
The control loop models the inductor current based on the PWM signal, ADC capcitor and output voltages (slowly changing), sample rate coil inductance. 
The PWM is turned on when ADC output current falls below a setpoint.
The PWM is turned off when the output current model rises above a setpoint,  
The model used for turn-off to avoid overshoot due to timing accuracy and sample latency.
A stable current pulse is generated limited only by the dropping capacitor voltage with a ripple limited only by the minimum PWM pulse width.

## Extended Functions

### Fire Button Debounce and Feedback.

To make button nice to use is to use debounce logic and provide feedback of its operation. 
To do this debounce counters are used to measure at least 5ms of time before sensing a 'press' and generating a 10msec beep for feedback, 
and 100ms of release before dectecting another. 

Multiple experments and measurements were done to get a good enough 'feeling' button. 

### Pulse Energy Accumulation

Ignition energy is a key parameter of igniters. Mensurements
are usefull to check this value.

The instantaneous power (Watts) of the capacitor and outputs can
each be calculated from the ADC samples as E = I * V.

The energy (Joules) over a time period can be accumulated by the sum
of the power measurement.

Accumulating the energy during ignition period gives allows a 10 Joule range with uJ resolution.

Measuring power of the output and capactor gives insights into the device efficiency and 
redunancy of calculation.

### Continuity Checking

Checking the continuity of an igniter is a resistance measurement to 
check for cases where the circuit is open or shorted.

After the system is armed and waiting for launce, at about 1Hz a short 1usec PWM pulse is generated.
Ohms law, R = E / I, is performed on the ADC samples to derive a resistance.

The resistance is averages and shown to be repeatable over the range 0.4 to 30.0 ohms.

Thresholds are applied to the resistance to decide when the continuity LED is turned on (1.0 to 16 ohms),
and a beep code is generated (A mute dip switch stops the beep codes after the first)

```
1 beep - OK, 1.0 to 8 Ohms
2 beeps - HI, over 8 ohms, but not open
3 beeps - Open circuit,
4 beeps - SHORT circuit maybe, under 1.0 ohms
```
The energy applied over this short pulse is accumulated and displayed by the previous function
and is usually under 0.25 mJoules which is not enough for ignition.

### HDMI VGA output

Normally on-board LEDs are usefull during development debug to present state to give some insight into
correct operation. Usually there are never enough LEDs as state can get quite involved.

LEDs can be replaced with pixels on an HDMI display. FPGA logic to generate HDMI outputs at XVGA 800x480x60Hz resolution is straight forward,
and digtal count values maintain the current X and Y locations on the screen. 

Connecting an internal signal to a given pixel can be as simple as the logical AND of test signal and desired pixel location, 
with all pels being ORed together to make the video signal
```
assign pel1 = xcount == 100 & ycount == 300 & test_signal1 == 1;
assign pel2 = xcount == 100 & ycount == 300 & test_signal2 == 1;
assign video = pel1 | pel2
```
Or more complex up to and including live text display of binary or hex measurement and text overlay like:
```
	string_overlay #(.LEN( 9)) _id4 (.clk(hdmi_clk), .reset(reset), .char_x(char_x), .char_y(char_y),
	.ascii_char(ascii_char), .x('h02),.y('h03), .out(id_str[4]), 
	.str(	( zoom == 0 ) ? " 21us/div" :
			( zoom == 1 ) ? " 43us/div" :
			( zoom == 2 ) ? " 85us/div" :
			( zoom == 3 ) ? "170us/div" :
			( zoom == 4 ) ? "340us/div" :
			( zoom == 5 ) ? "680us/div" :
			( zoom == 6 ) ? "1.4ms/div" :
			( zoom == 7 ) ? "2.7ms/div" :
			( zoom == 8 ) ? "5.5ms/div" :
			( zoom == 9 ) ? " 11ms/div" :
			( zoom == 10) ? " 22ms/div" :
			( zoom == 11) ? " 44ms/div" :
			/*zoom == 12)*/ " 87ms/div" ) );
```
Using this method the internals values can be displayed for: igniter resistance (ohms), capacitor and output energy (Joules), average ADC binary values, error statuses for ADC channels and PSRAM. Fixed point hex values are used for sake of logic simplicty. Noting that 5 hex digits ~ 1 million is helpful.


![Integrated in 3D box with VGA display](launch_op1.jpg "Integrated with VGA display")

### Scrolling Oscilloscope

The 3Mhz ADC samples can have min and max values calculated over longer intervals (1/60s) can be stored
into a 500 sample buffer and plotted and overlayed onto the display giving insight into the coarse
operation of the capacitor charge and discharge without missing a single transient during PWM operation
and allowing sufficient time to visually observer operation. 

This display is froze about 4 secondas after launch to show completer capacitor discharge.

### 32 MBytes Trace Buffer

The ADC sampels are stored to a 32 Mbyte trance buffer. With 3 Mhz sampling and 64 bits per sample we get 1.3 seconds of storage, which is 
sufficient to capture the full launch operation. 64 bits allows capturing of the 4x 12-bit adc samples, as well as the sampled model (estimated current)
and sampled PWM, and push-button signals as well as an burn-through detect signal.

The buffer is written continuously and only is stopped after launch finished, captureing the full detail from slightly before the launch button is pressed.

### Trace Buffer Display

The 800 samples of data is read from the trace buffer during video blanking and used to plot the sample data multiple scales and colors.
The starting address and stride allows examing the data from very coarse to finest full 3 Mhz detail. 

After launch the fire button is used to step through zoom ranges to see what occured during launch.

### Blipvert

A blipvert is a very brief television advertisement, lasting one second. The term and concept were used in the 1985 film Max Headroom: 20 Minutes into the Future.

HDMI provides a fast and standards compliant way to upload the 32 Mbyte trace buffer to a computer.
The memory is dumped to the RGB video HDMI output, with each visible display line having an memory address
followed by 1 kbyte of data all encoded into the RGB pixels.

This looks like messy noise, and take about 1 second to dump the entire buffer, thus Blipvert. 

The bipvert is activated by holding down the fire button for at least 1 second and continously dumps the buffer.

Using an HDMI capture card and capturing a second of the video noise gives the entire memory contents,
which can be recovered with a script from the captured video.

### Text Overlay

In addition to the dynamic logic derived text it is useful to have some fixed text overlay.

ROM equivalents for a 5x7 font table and a 16 color text overlay take advantage of the FPGA resources. 
Unfortuately with this lowest cost (SC) version of the fpga, ROM initialization is not available, so
a small amount of logic was used the read the onboard flash and load it into the rom's. 

This text allowed my to display some basic text mostly so I could remember details of beep or hex codes.

### Git Commit ID

It is always helpful to be able to trace a given build back to its git commit. 

Some bash code was used to insert the 7 hex digit git commmit id into the text overlay 
(lower right corner) before the FPGA was compiled. Very handy.



## FPGA Selection

The MAX-10 FPGAs from Intel/ALtera were selected as a) free tools were available and b) low cost devices and c) the instant-on (10mSec) boot time.
The 144 pin quad flat pack was chosen as it is hand solderable and probable. Devices from 2K to 25K logic cells are avaialable in pin compatible packages.
The free tools support System Verilog design input, and provide support integrating device specific features including differential and DDR IO and PLLs for clock generation. 

The design choice was the Intel Altera 10M04SCE144C8G, breaking down the part number:

```
10M - this family has free software tools.
04 - This was a $20 low cost device, has 4K Logic Elements (LEs) and is good for an unbelievable 99% utilization (wow).
SC - This is the cheapest compact device with significant cost savings no analog input and limited flash
E144 - Hand solderable quad flat pack
```

This 10M04 device also support pin compatibility over a 2 to 25K LE. The 10M04 is also a 'limited' device in that
it is actually an 8K LE device and limited by software to only allow 4K usage. This allow the vendors to sell
their "Floor sweepings", and provides 1/2 cost devices to us. The neat part is that 100% utilization of the 4K LEs is 
then possible as which LEs are used remains flexible, and the interconnect is sized for higher densities.

## Free Development Tools 

FPGA Dev Tools : Intel Altera Quartus Prime Lite v23.1

Schematic/PCB  : KiCad 7.0

## Conclusions, Pros and Cons

After this experience is a good time to reflect on the trade offs in
capactor discharge launch controllers vs a standard launch controller based with push button.

```
Pros:
+ Current Pulse delivers same power with any cabling
+ safety, can be part of an intrisically safe system
+ Resistance Measurement with 0.1 ohm precision
+ Energy Measurement with 1 uJ precision 
+ Repeatability with constant current with minimal ripple
+ Failure Analysys Data
+ Portable, with small battery
+ Battery Life is extended 
+ Reliable delivers energy over a wide range of cabling and igniters with self checking and reporting.

Cons:
- Button - it still needs a push button, and can be replaced by a push button.
- Expensive
- Estes - does not work well with estes igniters
- Complex system
- High Voltage
```










